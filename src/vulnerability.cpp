#include "vulnerability.h"

long double bayesVulnerability(Distribution &prior){
	return *std::max_element(prior.prob.begin(), prior.prob.end());
}

long double bayesVulnerability(Hyper &hyper){
	long double vulnerability = 0;

	for(int i = 0; i < hyper.num_post; i++){
		long double MAX = hyper.inners[0][i];
		for(int j = 1; j < hyper.prior.num_el; j++){
			if(MAX < hyper.inners[j][i]){
				MAX = hyper.inners[j][i];
			}
		}
		vulnerability += (hyper.outer.prob[i] * MAX);
	}

	return vulnerability;
}

long double gVulnerability(Gain &gain){
	long double MAX;
	long double acc = 0;

	for(int i = 0; i < gain.prior.num_el; i++){
		acc += (gain.prior.prob[i] * gain.matrix[0][i]); 
	}

	MAX = acc;
	for(int i = 1; i < gain.num_act; i++){
		acc = 0;
		for(int j = 0; j < gain.prior.num_el; j++){
			acc += (gain.prior.prob[j] * gain.matrix[i][j]);
		}

		if(acc > MAX){
			MAX = acc;
		}
	}

	return MAX;
}

long double gVulnerability(Hyper &hyper, Gain &gain){

	// Check if hyper.prior and gain.prior are equal
	bool distribution_are_equal = true;
	if(hyper.prior.num_el != gain.prior.num_el){
		distribution_are_equal = false;
	}else{
		for(int i = 0; i < hyper.prior.num_el; i++){
			if((hyper.prior.prob[i] - gain.prior.prob[i]) > EPS){
				distribution_are_equal = false;
			}
		}
	}

	if(!distribution_are_equal){
		fprintf(stderr, "The prior distribution from channel and actions are not the same!\n");
		exit(EXIT_FAILURE);
	}

	long double vulnerability = 0;

	for(int i = 0; i < hyper.num_post; i++){
		/* For each posterior distribution.*/

		long double MAX = -1;
		for(int k = 0; k < gain.num_act; k++){
			/* For each action k.*/

			long double acc = 0;
			for(int j = 0; j < hyper.prior.num_el; j++){
				/* For each secret j.*/
				acc += (hyper.inners[j][i] * gain.matrix[k][j]);
			}

			if(acc > MAX){
				MAX = acc;
			}
		}
		
		vulnerability += (hyper.outer.prob[i] * MAX);
	}

	return vulnerability;
}

long double kTries(Distribution &prior, int k){
	long double S = 0;

	std::vector<long double> sorted_prior = prior.prob;
	std::sort(sorted_prior.rbegin(), sorted_prior.rend());

	for(int i = 0; i < k; i++){
		S += sorted_prior[i];
	}

	return S;
}

long double kTries(Hyper &hyper, int k){
	long double S = 0;

	for(int i = 0; i < hyper.num_post; i++){
		/* For each posterior distribution.*/
		
		std::vector<long double> sorted_posterior;
		
		for(int j = 0; j < hyper.prior.num_el; j++){
			sorted_posterior.push_back(hyper.inners[j][i]);
		}

		std::sort(sorted_posterior.rbegin(), sorted_posterior.rend());

		long double pS = 0;
		for(int j = 0; j < k; j++){
			pS += sorted_posterior[j];
		}

		S += (hyper.outer.prob[i] * pS);
	}

	return S;
}
